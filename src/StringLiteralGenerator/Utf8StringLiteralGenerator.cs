using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace StringLiteralGenerator;

[Generator]
public partial class Utf8StringLiteralGenerator : ISourceGenerator
{
    private const string attributeText = @"// <auto-generated />
using System;
namespace StringLiteral
{
    [System.Diagnostics.Conditional(""COMPILE_TIME_ONLY"")]
    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]
    sealed class Utf8Attribute : Attribute
    {
        public Utf8Attribute(string s) { }
    }
}
";

    public void Execute(GeneratorExecutionContext context)
    {
        context.AddSource("Utf8Attribute", SourceText.From(attributeText, Encoding.UTF8));

        if (context.SyntaxReceiver is not SyntaxReceiver receiver) return;

        CSharpParseOptions options = (CSharpParseOptions)((CSharpCompilation)context.Compilation).SyntaxTrees[0].Options;

        Compilation compilation = context.Compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(attributeText, Encoding.UTF8), options));

        var buffer = new StringBuilder();

        var group = enumerate().GroupBy(x => x.type, x => x.method);

        foreach (var g in group)
        {
            var containingType = g.Key;
            var generatedSource = Generate(containingType, g, buffer);
            var filename = GetFilename(containingType, buffer);
            context.AddSource(filename, SourceText.From(generatedSource, Encoding.UTF8));
        }

        IEnumerable<(TypeInfo type, MethodInfo method)> enumerate()
        {
            foreach (var m in receiver.CandidateMethods)
            {
                if (!IsStaticPartial(m)) continue;

                var model = compilation.GetSemanticModel(m.SyntaxTree);

                if (m.ParameterList.Parameters.Count != 0) continue;
                if (model.GetDeclaredSymbol(m) is not { } methodSymbol) continue;
                if (!ReturnsString(methodSymbol)) continue;
                if (GetUtf8Attribute(methodSymbol) is not { } value) continue;


                yield return (new(methodSymbol.ContainingType), new(methodSymbol, value));
            }
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    class SyntaxReceiver : ISyntaxReceiver
    {
        public List<MethodDeclarationSyntax> CandidateMethods { get; } = new List<MethodDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // any field with at least one attribute is a candidate for property generation
            if (syntaxNode is MethodDeclarationSyntax methodDeclarationSyntax
                && methodDeclarationSyntax.AttributeLists.Count > 0)
            {
                CandidateMethods.Add(methodDeclarationSyntax);
            }
        }
    }
}
