using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace StringLiteralGenerator;

[Generator]
public partial class Utf8StringLiteralGenerator : ISourceGenerator
{
    private const string attributeText = @"// <auto-generated />
using System;
namespace StringLiteral
{
    [System.Diagnostics.Conditional(""COMPILE_TIME_ONLY"")]
    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]
    sealed class Utf8Attribute : Attribute
    {
        public Utf8Attribute(string s) { }
    }
}
";
    private const string attributeName = "StringLiteral.Utf8Attribute";

    public void Execute(GeneratorExecutionContext context)
    {
        context.AddSource("Utf8Attribute", SourceText.From(attributeText, Encoding.UTF8));

        if (context.SyntaxReceiver is not SyntaxReceiver receiver) return;

        CSharpParseOptions options = (CSharpParseOptions)((CSharpCompilation)context.Compilation).SyntaxTrees[0].Options;

        Compilation compilation = context.Compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(attributeText, Encoding.UTF8), options));

        var buffer = new StringBuilder();

        var group = enumerate().GroupBy(x => x.containingType, x => (x.methodName, x.value, x.accessibility));

        foreach (var g in group)
        {
            var containingType = g.Key;
            var generatedSource = generate(containingType, g);
            var filename = getFilename(containingType);
            context.AddSource(filename, SourceText.From(generatedSource, Encoding.UTF8));
        }

        string getFilename(INamedTypeSymbol type)
        {
            buffer.Clear();

            foreach (var part in type.ContainingNamespace.ToDisplayParts())
            {
                if (part.Symbol is { Name: var name } && !string.IsNullOrEmpty(name))
                {
                    buffer.Append(name);
                    buffer.Append('_');
                }
            }
            buffer.Append(type.Name);
            buffer.Append("_utf8literal.cs");

            return buffer.ToString();
        }

        IEnumerable<(INamedTypeSymbol containingType, string methodName, string value, Accessibility accessibility)> enumerate()
        {
            foreach (var m in receiver.CandidateMethods)
            {
                if (!IsStaticPartial(m)) continue;

                var model = compilation.GetSemanticModel(m.SyntaxTree);

                if (m.ParameterList.Parameters.Count != 0) continue;
                if (model.GetDeclaredSymbol(m) is not { } methodSymbol) continue;
                if (!ReturnsString(methodSymbol)) continue;
                if (GetUtf8Attribute(methodSymbol) is not { } value) continue;

                yield return (methodSymbol.ContainingType, methodSymbol.Name, value, methodSymbol.DeclaredAccessibility);
            }
        }

        string generate(INamedTypeSymbol containingType, IEnumerable<(string methodName, string value, Accessibility accessibility)> methods)
        {
            var x = containingType.ContainingNamespace;
            var ns = string.IsNullOrEmpty(x.Name) ? null : x.ToDisplayString();
            var name = containingType.Name;

            buffer.Clear();
            buffer.AppendLine("// <auto-generated />");

            if (ns is not null)
            {
                buffer.Append(@"namespace ");
                buffer.Append(ns);
                buffer.Append(@"
{
");
            }
            buffer.Append(@"partial class ");
            buffer.Append(name);
            buffer.Append(@"
{
");
            foreach (var (methodName, value, accessibility) in methods)
            {
                buffer.Append("    ");
                buffer.Append(AccessibilityText(accessibility));
                buffer.Append(" static partial System.ReadOnlySpan<byte> ");
                buffer.Append(methodName);
                buffer.Append("() => new byte[] {");

                foreach (var b in Encoding.UTF8.GetBytes(value))
                {
                    buffer.Append(b);
                    buffer.Append(", ");
                }

                buffer.Append(@"};
");
            }

            buffer.Append(@"}
");
            if (ns is not null)
            {
                buffer.Append(@"}
");
            }

            return buffer.ToString();
        }
    }

    private static string AccessibilityText(Accessibility accessibility) => accessibility switch
    {
        Accessibility.Public => "public",
        Accessibility.Protected => "protected",
        Accessibility.Private => "private",
        Accessibility.Internal => "internal",
        Accessibility.ProtectedOrInternal => "protected internal",
        Accessibility.ProtectedAndInternal => "private protected",
        _ => throw new InvalidOperationException(),
    };

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    class SyntaxReceiver : ISyntaxReceiver
    {
        public List<MethodDeclarationSyntax> CandidateMethods { get; } = new List<MethodDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // any field with at least one attribute is a candidate for property generation
            if (syntaxNode is MethodDeclarationSyntax methodDeclarationSyntax
                && methodDeclarationSyntax.AttributeLists.Count > 0)
            {
                CandidateMethods.Add(methodDeclarationSyntax);
            }
        }
    }
}
